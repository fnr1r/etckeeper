use std::io::{Result as IoResult, Write};

use rustix::fs::FileType;
use shellquote::ExtStrEscapeSinglequote;

use crate::metadata::{index::RepoFile, shared_info::SharedInfo};

fn path_escaped(file: &RepoFile) -> String {
    file.path.as_str().escape_singlequote()
}

#[inline]
fn meta_first_handle(out: &mut impl Write, file: &RepoFile) -> IoResult<()> {
    if file.file_type() != FileType::Directory {
        return Ok(());
    }
    let path = &file.path;
    if path.read_dir()?.next().is_some() {
        return Ok(());
    }
    let pathstr = format!("./{}", path).escape_singlequote();
    writeln!(out, "mkdir -p {}", pathstr)?;
    Ok(())
}

fn meta_first_iter(out: &mut impl Write, tree: &Vec<RepoFile>) -> IoResult<()> {
    for file in tree {
        meta_first_handle(out, file)?;
    }
    Ok(())
}

#[inline]
fn meta_handle_uid(out: &mut impl Write, info: &SharedInfo, file: &RepoFile) -> IoResult<()> {
    let uid = file.uid();
    if uid == 0 {
        return Ok(());
    }
    write!(out, "maybe chown")?;
    if let Some(user) = info.uid_to_user(uid) {
        write!(out, " {} ", user.escape_singlequote())?;
    } else {
        write!(out, " {} ", uid)?;
    }
    writeln!(out, "{}", path_escaped(file))?;
    Ok(())
}

#[inline]
fn meta_handle_gid(out: &mut impl Write, info: &SharedInfo, file: &RepoFile) -> IoResult<()> {
    let gid = file.gid();
    if gid == 0 {
        return Ok(());
    }
    write!(out, "maybe chgrp")?;
    if let Some(group) = info.gid_to_group(gid) {
        write!(out, " {} ", group.escape_singlequote())?;
    } else {
        write!(out, " {} ", gid)?;
    }
    writeln!(out, "{}", path_escaped(file))?;
    Ok(())
}

#[inline]
fn meta_handle_mode(out: &mut impl Write, file: &RepoFile) -> IoResult<()> {
    if file.file_type() == FileType::Symlink {
        return Ok(());
    }
    let mode = file.mode();
    writeln!(out, "maybe chmod 0{:o} {}", mode.bits(), path_escaped(file))?;
    Ok(())
}

#[inline]
fn meta_second_handle(out: &mut impl Write, info: &SharedInfo, file: &RepoFile) -> IoResult<()> {
    meta_handle_uid(out, info, file)?;
    meta_handle_gid(out, info, file)?;
    meta_handle_mode(out, file)?;
    Ok(())
}

fn meta_second_iter(
    out: &mut impl Write,
    info: &SharedInfo,
    files: &Vec<RepoFile>,
) -> IoResult<()> {
    for file in files {
        meta_second_handle(out, info, file)?;
    }
    Ok(())
}

pub fn meta_save(out: &mut impl Write, info: &SharedInfo, files: &Vec<RepoFile>) -> IoResult<()> {
    writeln!(out, "# Generated by etckeeper.  Do not edit.")?;
    writeln!(out)?;
    meta_first_iter(out, files)?;
    meta_second_iter(out, info, files)?;
    Ok(())
}
